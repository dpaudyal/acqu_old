//--Author	D Glazier    XXth Jun 2007	
//--Rev         JRM Annand   20th Jul 2007  Adapt for AcquMC foam  
//--Rev         JRM Annand   25th Jun 2008  Use WgtDensity  
//--Update      DI Glazier   12th Feb 2009  Add RecoilPol for CM, flRecPol
//--Update      DI Glazier   30th Apr 2010  Fix azimuthal distributions

//--Description
//                *** Acqu++ <-> Root ***
// Online/Offline Analysis of Sub-Atomic Physics Experimental Data 
//
// TMCPhotoPSInt
//
// Use data base generated by SAID partial wave analysis
// Database contains 16 observables associated with photoproduction of
// pseudo-scalar mesons and is tabulated as a function of incident photon
// energy and CM polar angle of meson. Phi dependence is calculated from
// observables when TFoam is initialised (TFoam dimension 3). Target
// Polarisation constitutes an optional 4th dimension

#ifndef __TMCPhotoPSInt_h__
#define __TMCPhotoPSInt_h__

#include "TH2.h"
#include "TString.h"
#include "TMCFoamInt.h"
#include "Riostream.h"
// Specify observable to be used
// 16 possible unpolarised, single-polarised, double polarised
enum{ EpsoDSG, EpsoP, EpsoS, EpsoT, EpsoG, EpsoH, EpsoE, EpsoF,
      EpsoOX, EpsoOZ, EpsoCX, EpsoCZ, EpsoTX, EpsoTZ, EpsoLX, EpsoLZ};
enum{ ENPhotoPSObs = 16 };
enum{ EEgamma, ETheta, EPhi, ETarget };

class TMCPhotoPSInt : public TMCFoamInt {
 protected:
  Int_t fNE;        // number of energies in data base
  Int_t fNth;       // number of polar angles in data base
  Int_t fNIntp;     // size of sub-database for each variable
  Double_t *fPSO;   // Array of Evaluated observables

 public:
  TMCPhotoPSInt( Int_t, Double_t*, TA2System*, Int_t);
  virtual ~TMCPhotoPSInt();
  virtual Double_t Density( Int_t, Double_t* ); 
  virtual void GenPSO();
  // Rotates Rcoil Pol to lab frame
  virtual void RecoilPol(Double_t, Double_t, Double_t, Double_t, Double_t);
  // Recoil Pol in CM
  virtual void RecoilPol(Double_t);
  virtual void ReadData( Char_t* );
  Int_t GetNE(){ return fNE; }
  Int_t GetNth(){ return fNth; }
  Double_t* GetPSO(){ return fPSO; }
  TVector3 fTransTarPol3; //the plane of the meson relative to transverse tar pol
  TVector3 fLinearPol3; //the plane of the meson relative to beam linear pol
  ClassDef(TMCPhotoPSInt,1)

};

// Beam Vector
// (0,0,0) unpolarised
// (1,0,0) lin pol horizontal
// (0,1,0) lin pol vertical
// (1./sqrt(2),1./sqrt(2),0) lin pol +45 deg.
// (-1./sqrt(2),1./sqrt(2),0) lin pol -45 deg.
// (0,0,1) LH circular pol
// (0,0,-1) RH circular pol

//-----------------------------------------------------------------------------
inline Double_t TMCPhotoPSInt::Density(Int_t nDim, Double_t *Xarg)
{
  // Complete determination of differential cross section, including
  // beam and target polarisation observable dependence

  Scale( Xarg, fXscaled );
  GenPSO();

  Double_t tarPol, result;
  Double_t phi = fXscaled[2];
  //transverse target polarisation
  Double_t TransPol=0;

  if((TransPol=fPolT->Perp())){//sort if transverse polarisation
    fTransTarPol3.SetX(TransPol);//magnitude of transverse pol
    fTransTarPol3.SetPhi(phi);        //phi angle of meson
    fTransTarPol3.RotateZ(-fPolT->Phi()); //rotate wrt target transverse pol
   }
  //linear beam polarisation
  Double_t LinearPol=0;//degree of linear polarisation
  if((LinearPol=fPolB->Perp())){//sort if linear polarisation
    fLinearPol3.SetX(LinearPol);//magnitude of linear pol
    fLinearPol3.SetPhi(phi); //phi angle of meson
    fLinearPol3.RotateZ(-fPolB->Phi());//rotate wrt photon polarisation
  }
  /* Double_t cos2phi = TMath::Cos( 2*phi ); */
  /* Double_t sin2phi = TMath::Sin( 2*phi ); */
  /* Double_t cosphi = TMath::Cos( phi ); */
  /* Double_t sinphi = TMath::Sin( phi ); */
  Double_t cos2phi = TMath::Cos( 2*fLinearPol3.Phi() );
  Double_t sin2phi = TMath::Sin( 2*fLinearPol3.Phi() );
  Double_t cosphi = TMath::Cos( fTransTarPol3.Phi() );
  Double_t sinphi = TMath::Sin( fTransTarPol3.Phi() );
  //Is the target z polarisation parallel or anti-parallel
  if( nDim < 4 ) tarPol = 1;
  else if( Xarg[3] < 0.5 ) tarPol = -1;
  else tarPol = 1;

  result = fPSO[EpsoDSG]*(1-fPSO[EpsoS]*LinearPol*cos2phi
  +TransPol*cosphi*(-fPSO[EpsoH]*LinearPol*sin2phi+fPolB->Z()*fPSO[EpsoF])
  -TransPol*sinphi*(fPSO[EpsoT]+fPSO[EpsoP]*LinearPol*cos2phi)
  -tarPol*fPolT->Z()*(-fPSO[EpsoG]*LinearPol*sin2phi+fPolB->Z()*fPSO[EpsoE]));

  return WgtDensity( result );
}

//-----------------------------------------------------------------------------
inline void TMCPhotoPSInt::GenPSO()
{
  // Interpolate values of 16 observables for given
  // Energy and Angle
  Int_t nd = fNDim;
  fNDim = 2;
  Double_t* yN = fYN;
  for(Int_t io=0; io<ENPhotoPSObs; io++){
    fYN = yN + io * fNIntp;
    fPSO[io] = LinInterpN(fXscaled);
  }
  fYN = yN;
  fNDim = nd;
}

#endif
